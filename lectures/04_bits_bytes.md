---
title: 04. ინფორმაციის ენკოდირება ბაიტებში
parent: ლექციები
---

<section class="non-compulsory" markdown="1">
ამ ფერის ფონით გამოყოფილია არასავალდებულო ნაწილები. უშუალოდ ამ ნაწილიდან კითხვა არ მოვა, თუმცა მისი წაკითხვა შეიძლება საგრძნობლად დაგეხმაროთ დანარჩენი მასალის უკეთ აღქმასა და ათვისებაში. შეეცადეთ გაიგოთ, მაგრამ დიდ დროს და ენერგიასაც ნუ დახარჯავთ
</section>


ამ ლექციის საკვანძო ტერმინები
- ენკოდირება/დეკოდირება
- პიქსელი, რეზოლუცია
- ფაილის ფორმატი
- კომპრესირება/დეკომპრესირება

# ინფორმაციის ენკოდირება ბაიტებში (და უკან)
ჩვენ ვისწავლეთ, რომ კომპიუტერში ინფორმაცია ბიტებში ინახება და მუშავდება, მაგრამ ჯერ შეუძლებელია იმის აღქმა, თუ როგორ გადაითარგმნება სხვადასხვა სახის ინფორმაცია (სურათი, ვიდეო, აუდიო, ტექსტი) ბიტებში.

ამ ლექციაში შევეცდებით კარგად გავიგოთ, რას ნიშნავს, როდესაც ვამბობთ რომ კომპიუტერში ყველაფერი არის რიცხვი. როგორ შეიძლება, რომ მხოლოდ და მხოლოდ ციფრების მიმდევრობით მუშაობდეს ყველა ციფრული პროგრამა, რომელსაც ვიყენებთ?

### სურათები
დავიწყოთ ყველაზე პრიმიტიული მაგალითით.

![](https://futureeverythingmsf.files.wordpress.com/2015/02/image.png)

თითო უჯრას **პიქსელი** ეწოდება. როგორ გავაუმჯობესოთ სურათის ხარისხი?

![](https://images.ctfassets.net/1khq4uysbvty/3ilqI18qg7SJCwSvj52GWr/6a6a08e458503ed55db4651035763b49/pixel_density.png?&w=736)

1. გავზარდოთ პიქსელების რაოდენობა ![](https://kronos-images.schoolmouv.fr/2-fnx-snt-c15-img01.png)
2. გავზარდოთ ერთ პიქსელში ბიტების რაოდენობა - ორის მაგივრად მეტი ფერი გვგქონდეს - თუ თითო პიქსელი ერთი ბაიტი იქნება, მაშინ 255 ფერს გამოვსახავთ (ნაცრისფერის ტონები) 

![](https://seis.bristol.ac.uk/~ggjlb/teaching/ccrs_tutorial/tutorial/graphics/content/pixel.gif)

#### ფერები
ციფრულ ფორმატში ფერები გამოისახება **rgb** მნიშვნელობის გამოყენებით. თითო საბაზისო ფერისთვის (წითელი, მწვანე, ლურჯი) გამოყოფილია ერთი ბაიტი - ანუ ერთი პიქსელისთვის სამ ბაიტს ვინახავთ.

#### სურათის გამოსახვა ეკრანზე
სურათის პიქსელებად შენახვა ზუსტად შეესაბამება იმ პრინციპს, როგორც ახლა ეს გამოსახულება შენს ეკრანზეა შექმნილი. 
ყველა ეკრანს აქვს **რეზოლუცია**,მაგალითად, Full HD - 1920x1080. ეს ნიშნავს, რომ ეკრანზე არის 2,073,600 კვადრატი, რომელშიც თავისდავად 3-3 მართკუთხედია - ლურჯის, წითელის და მწვანესთვის. rgb მნიშვნელობა სწორედ ასე გამოისახება.

![](https://ak.picdn.net/shutterstock/videos/1040393114/thumb/1.jpg)

### კომპრესირება
ერთი fhd სურათის ზომა 6,220,800 ბაიტი ანუ 6 MB (მეგაბაიტი) იქნება. შეიძლება ცალკე აღებულად არც ისე დიდი ზომაა, მაგრამ ზოგჯერ ამ ზომის შემცირება გვჭირდება (ჩვენ ან სხვას). წარმოიდგინეთ, რამდენი სურათი იპოსტება/იგზავნება სოციალურ მედიაში ყოველ წამს. ისიც გეცოდინებათ, რომ მესენჯერში გაგზავნისას სურათი "ხარისხს კარგავს". 
სურათის ზომის შემცირება ერთი შეხედვით მარტივი, მაგრამ არც ისე პრიმიტიული პრობლემაა. რა ლოგიკით გადავწყვიტოთ, რომელი პიქსელები ამოვაგდოთ? ჩვენ უბრალოდ ზომის (ანუ ბაიტების რაოდენობის) შემცირება ხომ არ გვინდა - გვსურს ეს ისე გავაკეთოთ, რომ მნიშვნელოვანი ინფორმაცია არ დაიკარგოს. ამ პროცესს კომპრესირება ეწოდება და სურათების შენახვის გარდა ბევრ სხვა ფაილშიც გამოიყენება.

### სურათის შენახვის ფორმატები
#### JPEG
კონკრეტული სიგანის (მაგალითად 2) კვადრატებზე "საშუალოს" აღება და ამ 4 (2x2) პიქსელის მაგივრად 1 მნიშვნელობის ჩაწერა
![](https://cdn.geckoandfly.com/wp-content/uploads/2016/12/lossy-compression-ratios.jpg)

![](https://cdn.fstoppers.com/styles/large-16-9/s3/lead/2019/12/c5cbc7dcbf92b86b43878299aea59921.jpg)
#### JPG vs PNG
png ფორმატს ბევრი უპირატესობა აქვს - არ ჩანს "გადღაბნილი" პიქსელები, არსებობს გამჭვირვალეობისთვის გამოყოფილი ბაიტი. რომელია ოპტიმალური? ამის განსაზღვრა მხოლოდ კონკრეტული შემთხვევების მიხედვით შეიძლება.
![jpg vs png](https://www.bluearcher.com/files/admin/blog-images/blogs-resources/jpg-vs-png-comparison-chart-resized-1.png)

#### RAW
გამოიყენება ფოტოგრაფიაში. კამერის სენსორის ინფორმაცია კომპრესირების გარეშე ინახება, რაც ბევრად დიდი ზომის ფაილს ქმნის, თუმცა დიდი რაოდენობით ინფორმაციას ინახავს რომელსაც კომპრესირება დაკარგავდა - ეს ფოტოს დამუშავების უფრო ხარისხიან საშუალებას გაძლევს (რის შემდეგადაც შეგიძლია გამოაქვეყნო კომპრესირებული).


### ვიდეოები
როგორ მიიღება ვიდეო? ბევრი სურათის (frame) სწრაფად ჩვენებით. მაგალითად, 30 ან 60 წამში - 30/60 **fps** (frames per second). მოდი უხეშად დავითვალოთ, რამდენი მეგაბაიტი გამოვა ერთ წუთიანი ვიდეო. რადგან ერთი კადრი 6 მეგაბაიტამდეა, ხოლო თითო წამში 60 კადრია, ერთი წამი 360 მეგაბაიტი გამოდის. ზუსტად ოთხი წამი იქნება საჭირო, რომ გეგაბაიტამდე ავიდეთ! ანუ საშუალო 32 გეგაბაიტიანი ტელეფონი ვიდეოს ორ წუთსაც ვერ ჩაიწერს. რა თქმა უნდა ეს ასე არ არის და სხვადასხვა ფორმატის ვიდეოს (mp4, mov...) შენახვისას გამოიყენება სხვადასხვა კომპრესირების ალგორითმები, რომლებიც ვიდეოს ზომას ამცირებს. შეიძლება წამში 60 კადრია, მაგრამ მათი უმრავლესობა მხოლოდ რამდენიმე პიქსელით განსხვავდება ერთმანეთისგან - მოდი, შევინახოთ მხოლოდ ის პიქსელები, რომლებიც შეიცვალა. 

### ტექსტი
#### ascii ფორმატი
![ascii table](https://miro.medium.com/max/3284/1*DHEm7FO7ZATjvH19dmKwoA.png)
#### utf-8 ფორმატი
ascii ფორმატი ძალიან ეკონომიური იყო და სხვა გზა არც ქონდათ - თავდაპირველ კომპიუტერებში მართლა თითოეული ბაიტი ძალიან ძვირი ჯდებოდა. ამიტომ, ეს 255 ციფრი ყველა ქვეყანამ თავისთვის მოირგო - ზოგგან ლათინურ სიმბოლოებს ნიშნავდა, ზოგგან კირილიცას ასოები იყო ჩაწერილი, იაპონელებს თავიანთი იეროგლიფების ენკოდირებაზე მოუხდათ თავის მტვრევა. საბოლოოდ კი ეს ფაილები ბაბილონის გოდოლს გავდა - ერთი ქვეყნის კომპიუტერი ვერაფერს გაუგებდა მეორისას. ამიტომ (ნებაყოფლობით) შეიქმნა  კომისია, რომელიც შეთანხმდა უფრო ფართო - 8 ბაიტიან ფორმატზე, სადაც ყველა ანბანი ჩაეტეოდა.

### არქივები (zip, rar)
ფაილებზე ოპერაციას აქვს ფიქსირებული დანახარჯი ერთ ფაილზე. მაგალითად, თუ ვაკოპირებთ ათ ცალ 100MB ფაილს, ეს პროცესი უფრო დიდ დროს წაიღებს, ვიდრე ერთი ცალი 1000MB ფაილი. ეს ფიქსირებული დანახარჯები არის, მაგალითად, გადაკოპირების ადგილას იმის შემოწმება, არის თუ არა ფაილისთვის საკმარისი ადგილი. შემდეგ გადაკოპირების ადგილას სპეციალური ცხრილის შეცვლა, რომ იმ ფოლდერში ახალი ფაილი ემატება და ა.შ. ეს დიდი პრობლემა ხდება, როდესაც საქმე ასობით ან ათასობით ფაილს ეხება. გადაწყვეტა არის ფაილების დროებით ერთმანეთზე მიკერება - დაარქივება, თითქოს ერთი ფაილი იყოს. თავდაპირველი განცალკევების დასაბრუნებლად ვაკეთებთ ამოარქივებას.

არქივების კიდევ ერთ პასუხისმგებლობა არის კომპრესირება - იმის ცოდნის გარეშე, თუ რა ფორმატის ფაილია. მარტივი მაგალითი, თუ ფაილის რიცხვითი მნიშვნელობა არის 131237333338588888222211111334, ძალიან ბევრ რიცხვს ვამეორებთ. ჩვენ შეგვიძლია შემოვიღოთ ნიშანი G, რაც იგულისხმებს, რომ მის შემდეგ იმის მაგივრად, რომ 5 ცალი 3 დავწეროთ, დავწერთ, რომ 5 ცალი 3 არის იმ ადგილას. 131237G5385G58G42G51334. ჩვენი 'ფაილის ზომა' 30 სიმბოლოდან 23-მდე ჩამოვიდა. ეს კი ათობით სისტემაში - ორობითში გამეორებები ბევრად უფრო ხშირია. დეკომპრესირებისას ფაილი უბრუნდება თავდაპირველ ზომას.

ამ ორივე პროცესის შებრუნებას - ამოარქივებას და დეკომპრესირებას - სჭირდება გამოთვლა და შესაბამისად დრო - ფაილის ყოველ ჯერზე გასახსნელად არ გამოდგება. არქივებს იყენებენ გასაგზავნად, გადასაკოპირებლად ან გრძელვადიანი შენახვისთვის

## დოკუმენტები
დღევანდელ ლექციაში ვნახეთ, რომ სხვადასხვა ტიპის ინფორმაცია სხვადასხვანაირად ენკოდირდება ბაიტებში. მეტიც, სურათის მაგალითზე, ერთი და იგივე ტიპის ინფორმაციისთვისაც სხვადასხვა ტიპის ენკოდირება შეიძლება. მაგალითად, JPEG უფრო ეფექტურია ფოტოებისთვის, PNG კი - გრაფიკულისთვის. 

რიცხვების შემდეგ ერთ-ერთი პირველი, რისთვისაც კომპიუტერი გამოიყენეს, ტექსტი იყო - სხვადასხვა ტიპის დოკუმენტების შესაქმნელად. რამდენიმე პროგრამა გაჩნდა, რომელსაც წარმოედგინა როგორ გადაგვეთარგმნა ტექსტის სხვადასხვა ატრიბუტები (გაცენტრვა, გამუქება).

### 1. ტექსტის ჩაწერა ascii/utf-8-ით, ისე რომ ნებისმიერი ტექსტური პროგრამა გახსნის
თვითონ ტექსტი შეიცავს . მაგალითად, markdown-ის წინაპარი org-mode-ის მაგალითი
```org
* სათაური
** ქვესათაური

სია
- სიის
- წევრი
- **bold**
```
- ამ სიმბოლოების დაწერა მარტივია
- თუ გინდა, წერის პროცესი აასწრაფო, დაწერ პროგრამას, რომელიც გაითვალისწინებს ამ კონვენციებს (და მაგალითად, enter-ზე დაჭერისას სიის შემდეგ ელემენტს ავტომატურად დაიწყებს)

markdown ერთ-ერთი ყველაზე მოსახერხებელი ფორმატია ტექსტთან სამუშაოდ, თუმცა ნაკლი ისაა, რომ რთულია უფრო კომპლექსური სტრუქტურის გამოსახვა

### 2. ტექსტის ჩაწერა ბაიტებში ენკოდირებით - მხოლოდ ამ ფორმატის პროგრამები გახსნიან
აი როგორ გამოიყურება pdf, თუ მას წავიკითხავთ, როგორც ტექსტს. 

ზოგი ბაიტი შემთხვევით აღმოჩნდება, რომ რაღაც სიმბოლოს ნიშნავს, მაგალითად ლათინურ ასოს, ციფრს. ეს უბრალოდ შემთხვევითობაა, ფაილში უბრალოდ რიცხვი წერია, რომლის მნიშვნელობაც მხოლოდ იმ პროგრამას შეუძლია გაიგოს, რომელშიც ენკოდირება/დეკოდირების ალგორითმია.
```org
�#Ż�|2�UW]%��p�ٹSt�dj�Ew�2�J�ù��L��l�Q��()H��EkR�g�W��
��s��^���%P��z�]4R���=.���F�z
]����7��Ҩ	s���3,�)k����E�5':��G�4ݢ�>ԇ�Z��$4�D�rQS#ܹ����&e$�'��r������Z�YT
��@�����UH'i�����uΩ���36@�J���}�29pW�׌v�,L�|���g~�����B1�Y�C_�lm
```
