---
title: 04ბ. ოპერატიული სისტემა, ფაილები, პროგრამები
parent: ლექციები
---

ეს ლექცია არ არის სავალდებულო

# პროგრამები

## რა არის პროგრამა
პროცესორის ინსტრუქციების ერთობლიობა კონკრეტული დავალების შესასრულებლად.


## პროგრამის გაშვების სქემა
- ოპერატიული სისტემა 
    - წაიკითხავს პროგრამის კოდს, რომელიც წერია დისკზე და გადაიტანს მეხსიერებაში
    - გამოუყოფს საწყის მეხსიერებას
    - პროცესორს მიუთითებს პროგრამის კოდის პირველ ხაზზე მეხსიერებაში
- ამის შემდეგ, პროგრამას შეუძლია
    - მოითხოვოს მეტი მეხსიერება (ოპერატიულ სისტემას მისცემს მეხსიერების ზომას, იგი გამოუყოფს ამ ზომის ადგილს და დაუბრუნებს მისამართს, საიდანაც არის იმ ზომის ადგილი გამოყოფილი. მაგალითად, თუ გვჭირდება 100 ბაიტი, ოპერატიული სისტემა გვეტყვის რომ ეს ბაიტები გამოყო 3456 მისამართზე, ანუ 3456-დან 3556-მდე შეგვიძლია გამოვიყენოთ
    - გაათავისუფლოს მეხსიერება, რომელიც არ ჭირდება ხშირად პროგრამისტებს ეს ავიწყდებათ ხოლმე, რის გამოც შეიძლება მაგ. კომპიუტერმა დაიწყოს გაჭედვა, რასაც “შველის” პროგრამის გამორთვა და თავიდან ჩართვა ან კომპიუტერის გადატვირთვა
    -   თუ პროგრამა შეეცდება იმ მეხსიერების წაკითხვა/ჩაწერას, რომელიც ოპერატიულ სისტემას არ მოუცია, ოპერატიული სისტემა მომენტალურად გათიშავს პროგრამას
- პროგრამის გამორთვისას, ოპერატიული სისტემა
    - ათავისუფლებს პროგრამის გამოყენებულ მეხსიერებას
    - შლის პროგრამის კოდს მეხსიერებიდან




## პარალელური პროცესები
ასეთი მაგალითით შეგვიძლია წარმოვიდგინოთ როგორ ამუშავებს ერთ პროგრამას პროცესორი, მაგრამ ჩვენს კომპიუტერში უამრავი რამ ხდება პარალელურად. როგორ კეთდება ეს, 

ყოველი ახალი პროგრამა, რომელსაც ჩვენ ვრთავთ, ემატება კომპიუტერის

#### ერთი პროგრამის პარალელური პროცესები
პარალელური პროცესები მხოლოდ, სხვადასხვა პროგრამებს შორის არ გამოიყენება, მაგალითად
- ბრაუზერი როდესაც ფაილს იწერს, ჩვენ მაინც შეგვიძლია საიტის გამოყენება. ერთ საიტზე როდესაც . ამისთვის ოპერატიულ სისტემას სპეციალური ინტერფეისი აქვს, რომელიც პროგრამებს შეუძლიათ გამოიყენონ და თხოვონ მას, კოდის რაღაც ნაწილი ცალკე პროცესად გაუშვას
- ყველა gui აპლიკაციაში - მოხმარებლის ინტერაქცია არ უნდა ბლოკავდეს პროგრამის სხვა ნაწილებს და პირიქით

### რამდენიმე ბირთვიანი პროცესორები
პროცესორის ბირთვის სიჩქარის ორჯერ ასწრაფება საკმაოდ რთული და ზოგჯერ შეუძლებელი დავალებაა, მაგრამ კომპიუტერის სიჩქარის ზრდა სხვანაირადაცაა შესაძლებელი - შეგვიძლია ორი ბირთვი გვგქონდეს და ორი პროცესი, თუ ერთმანეთს ხელს არ შეუშლიან, ამ ბირთვებზე გავანაწილოთ. შედეგად, ორი დავალების შესრულებას ორჯერ უფრო ჩქარა ახერხებს კომპიუტერი. ბირთვების რაოდენობა ერთ-ერთი გადამწყვეტი ფაქტორია პროცესორის სიჩქარისთვის



## რა არის ინტერფეისი
წინასწარ შეთანხმებული ან მოწოდებული მოწყობილობა ან სისტემა (აბსტრაქციასთან) ინტერაქციისთვის. მაგალითად, როდესაც ჩვენს ლეპტოპს ან კომპიუტერს ვუერთებთ პრინტერს, ეს პრინტერი აინსტალირებს ე.წ. დრაივერს - ასწავლის ჩვენს კომპიუტერს, რა ინსტრუქციაზე რა ბრძანებას შეასრულებს. ამის შემდეგ, ჩენმა ლეპტოპმა იცის, რომ როდესაც ამ პრინტერის მონიშვნით დავაჭერთ დაბეჭდვის ღილაკს, 

ინტერფეისი ეწოდება, ასევე, კარელის ბრძანებების ერთობლიობას, რომელიც თქვენ იცით, რომ ედიტორში დაწერისას იმუშავებს.

ინტერფეისი არის კომპიუტერთან და პროგრამებთან ინტერაქციის გზაც
- gui graphical user interface მაუსისა და ფანჯრების მეშვეობით ინტერაქცია
- cli command line interface ტერმინალში შეყვანილი ბრძანებებით ინტერაქცია

ხშირ შემთხვევაში ერთი თასქის შესრულება ორივე გზით არის შესაძლებელი. თუმცა ბევრ პროგრამას მხოლოდ ერთ-ერთი ინტერფეისი აქვს.

მაგალითად, იმისთვის რომ Word ფორმატის ფაილიდან pdf შევქმნა, Microsoft Office უნდა გავხსნა, შევიდე მენიუში და ა.შ. ალტერნატიული პროგრამა, Libreoffice-ს კი გარდა ამ გზისა, აქვს cli ინტერფეისი, სადაც შეგიძლია ათობით ფაილი ერთი ტექსტის დაწერით გადააკონვერტირო.

```sh
mkdir my-folder
cd my-folder
libreoffice --headless --convert-to pdf my.docx
libreoffice --headless --convert-to pdf *.docx #რაც ამ ფოლდერში docx ფაილი არის, ყველა გადააკონვერტირე pdf-ად
```

### cli interface უპირატესობები
- შესაძლებელია ბრძანებების შენახვა სხვადასხვა დავალებების ავტომატიზირებისთვის
- შესაძლებელია პროგრამირების ენის შესაძლებლობების გამოყენება
- უფრო მარტივი და სწრაფია სხვა კომპიუტერთან დისტანციური კავშირი (და იმ კომპიუტერზე ბრძანებების შესრულება). გრაფიკული დისტანციური კავშირის პროგრამაა, მაგალითად, teamviewer
- ბრძანებების დამახსოვრების შემდეგ უბრალოდ იწყებ იმის წერას, რისი გაკეთებაც გინდა, და auto-complete ფუნქციით გეხმარება ტერმინალი

### os interface
ყველა პროგრამა თავიდან არ წერს სურათის ეკრანზე გამოსახვის კოდს - უბრალოდ ოპერატიულ სისტემას აძლევს კონკრეტული რეზოლუციის პიქსელებს. ოპერატიული სისტემაა პასუხისმგებელი კლავიატურის, მაუსის, სხვადასხვა გარე მეხსიერების და მოწყობილობების მართვაზეც.


# ოპერატიული სისტემა
## ოპერატიული სისტემის მუშაობის სქემა
თვითონ ოპერატიული სისტემაც პროგრამაა, რომელიც უნდა გაეშვას და რომლის ინსტრუქციებიც პროცესორმა უნდა წაიკითხოს. თუ პროცესორისთვის პროგრამის 

ჩართვის ღილაკზე დაჭერისას პროცესორი სპეციალურ, დისკის წინასწარ განსაზღვრულ (და ძალიან დაცულ) ნაწილზე კითხულობს ჩართვის (boot) კონფიგურაციას, სადაც მითითებულია ოპერატიული სისტემის ფაილების მდებარეობა და საჭირო პარამეტრები. ჩართვის დროს ხდება ამ ფაილების წაკითხვა და ოპერატიული სისტემა ინიციალიზაციისთვის საჭირო ნაბიჯებს იწყებს, რომლის დასრულების შემდეგაც გვხვდება login screen.


## მთავარი პასუხისმგებლობები
- პროცესების მართვა: რომელი პროგრამის გაშვების ჯერია, რომელმა პროგრამამ გაჭედა
- ფიზიკური ნაწილების მართვა და დაცვა:
    + რომელ პროგრამას რა მეხსიერებაზე აქვს წვდომა
    + პერიფერიების (usb, disk, ethernet, wifi card, sound card) დაკავშირება
- ფაილების მართვა

სხვა ყველაფერი არის დამატებითი პროგრამა (მაგალითად, ფაილის შესაბამისი პროგრამის პოვნა, რომ პროგრამის გახსნის გარეშე ჩაირთოს)




<section class="non-compulsory" markdown="1">
    
### ლინუქსი
windows-ზე ეს პროგრამები ავტომატურად არის დაყენებული და მისი შეცვლა ან კონფიგურაცია თითქმის შეუძლებელია. ლინუქსზე ყველაფერი სხვანაირადაა - არის ბევრი ალტერნატივა იმის, თუ როგორი არის ოპერატიული სისტემა და ხშირ შემთხვევაში ყველაფერზე კონტროლი გაქვს. თუ უველაფრის სათითაოდ არჩევა არ გინდა, არსებობს ბევრი წინასწარ შერჩეული Desktop Environment, რომლებიც unified experience-ს სთავაზობენ მომხმარებელს.

დამატებითი პროგრამები
- **display manager**
- **window manager**
- **panel**
- **file explorer**
- **notification service**

</section>